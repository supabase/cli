package utils

import (
	"bufio"
	"bytes"
	"encoding/json"
	"errors"
	"io"
	"regexp"
	"strconv"
	"strings"

	"github.com/docker/docker/pkg/jsonmessage"
	"github.com/docker/docker/pkg/stdcopy"
)

func ProcessPullOutput(out io.ReadCloser, p Program) error {
	dec := json.NewDecoder(out)

	downloads := make(map[string]struct{ current, total int64 })

	for {
		var progress jsonmessage.JSONMessage

		if err := dec.Decode(&progress); err == io.EOF {
			break
		} else if err != nil {
			return err
		}

		if strings.HasPrefix(progress.Status, "Pulling from") {
			p.Send(StatusMsg(progress.Status + "..."))
		} else if progress.Status == "Pulling fs layer" || progress.Status == "Waiting" {
			downloads[progress.ID] = struct{ current, total int64 }{
				current: 0,
				total:   0,
			}
		} else if progress.Status == "Downloading" {
			downloads[progress.ID] = struct{ current, total int64 }{
				current: progress.Progress.Current,
				total:   progress.Progress.Total,
			}

			var overallProgress float64
			for _, percentage := range downloads {
				if percentage.total > 0 {
					progress := float64(percentage.current) / float64(percentage.total)
					overallProgress += progress / float64(len(downloads))
				}
			}

			p.Send(ProgressMsg(&overallProgress))
		}
	}

	p.Send(ProgressMsg(nil))

	return nil
}

func ProcessDiffOutput(p Program, out io.Reader) ([]byte, error) {
	var diffBytesBuf bytes.Buffer
	r, w := io.Pipe()
	doneCh := make(chan struct{}, 1)

	go func() {
		scanner := bufio.NewScanner(r)
		re := regexp.MustCompile(`(.*)([[:digit:]]{2,3})%`)

		for scanner.Scan() {
			select {
			case <-doneCh:
				return
			default:
			}

			line := scanner.Text()

			if line == "Starting schema diff..." {
				percentage := 0.0
				p.Send(ProgressMsg(&percentage))
			}

			matches := re.FindStringSubmatch(line)
			if len(matches) != 3 {
				continue
			}

			p.Send(StatusMsg(matches[1]))
			percentage, err := strconv.ParseFloat(matches[2], 64)
			if err != nil {
				continue
			}
			percentage = percentage / 100
			p.Send(ProgressMsg(&percentage))
		}
	}()

	if _, err := stdcopy.StdCopy(&diffBytesBuf, w, out); err != nil {
		return nil, err
	}

	doneCh <- struct{}{}
	p.Send(ProgressMsg(nil))

	// TODO: Remove when https://github.com/supabase/pgadmin4/issues/24 is fixed.
	diffBytes := bytes.TrimPrefix(diffBytesBuf.Bytes(), []byte("NOTE: Configuring authentication for DESKTOP mode.\n"))

	return filterDiffOutput(diffBytes)
}

type DiffDependencies struct {
	Type string `json:"type"`
}

type DiffEntry struct {
	Type             string             `json:"type"`
	Status           string             `json:"status"`
	DiffDdl          string             `json:"diff_ddl"`
	GroupName        string             `json:"group_name"`
	Dependencies     []DiffDependencies `json:"dependencies"`
	SourceSchemaName *string            `json:"source_schema_name"`
}

func filterDiffOutput(diffBytes []byte) ([]byte, error) {
	if len(diffBytes) == 0 {
		return diffBytes, nil
	}

	var diffJson []DiffEntry
	if err := json.Unmarshal(diffBytes, &diffJson); err != nil {
		return nil, err
	}

	filteredDiffDdls := []string{`-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.`}

	for _, diffEntry := range diffJson {
		if diffEntry.Status == "Identical" || diffEntry.DiffDdl == "" {
			continue
		}

		switch diffEntry.Type {
		case "extension", "function", "mview", "table", "trigger_function", "type", "view":
			// skip
		default:
			continue
		}

		{
			doContinue := false
			for _, dep := range diffEntry.Dependencies {
				if dep.Type == "extension" {
					doContinue = true
					break
				}
			}

			if doContinue {
				continue
			}
		}

		isSchemaIgnored := func(schema string) bool {
			for _, s := range InternalSchemas {
				if s == schema {
					return true
				}
			}
			return false
		}

		if isSchemaIgnored(diffEntry.GroupName) ||
			// Needed at least for trigger_function
			(diffEntry.SourceSchemaName != nil && isSchemaIgnored(*diffEntry.SourceSchemaName)) {
			continue
		}

		filteredDiffDdls = append(filteredDiffDdls, strings.TrimSpace(diffEntry.DiffDdl))
	}

	return []byte(strings.Join(filteredDiffDdls, "\n\n") + "\n"), nil
}

func ProcessPsqlOutput(out io.Reader, p Program) error {
	r, w := io.Pipe()
	doneCh := make(chan struct{}, 1)

	go func() {
		scanner := bufio.NewScanner(r)

		for scanner.Scan() {
			select {
			case <-doneCh:
				return
			default:
			}

			line := scanner.Text()
			p.Send(PsqlMsg(&line))
		}
	}()

	var errBuf bytes.Buffer
	if _, err := stdcopy.StdCopy(w, &errBuf, out); err != nil {
		return err
	}
	if errBuf.Len() > 0 {
		return errors.New("Error running SQL: " + errBuf.String())
	}

	doneCh <- struct{}{}
	p.Send(PsqlMsg(nil))

	return nil
}
