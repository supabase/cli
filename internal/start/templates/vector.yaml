api:
  enabled: true
  address: '0.0.0.0:9001'

sources:
  docker_syslog:
    type: 'syslog'
    address: '0.0.0.0:9000'
    mode: 'tcp'
    path: '/tmp/socket'

transforms:
  project_logs:
    type: remap
    inputs:
      - docker_syslog
    source: |-
      .project = "default"
  router:
    type: route
    inputs:
      - project_logs
    route:
      kong: '.appname == "{{ .KongId }}"'
      auth: '.appname == "{{ .GotrueId }}"'
      rest: '.appname == "{{ .RestId }}"'
      realtime: '.appname == "{{ .RealtimeId }}"'
      storage: '.appname == "{{ .StorageId }}"'
      db: '.appname == "{{ .DbId }}"'
  auth_logs:
    type: remap
    inputs:
      - router.auth
    source: |-
      .message = parse_json!(.message)
      .event_message = .message.msg
      .metadata.level = .message.level
      .metadata.timestamp = .message.time
      .metadata.app = .appname
      .metadata.ip = .source_ip
      .metadata.project = "default"
      del(.message)
      del(.procid)
      del(.severity)
      del(.source_id)
      del(.source_type)
      del(.timestamp)
      del(.facility)
      del(.host)
      del(.id)
      del(.appname)
  kong_logs:
    type: remap
    inputs:
      - router.kong
    source: |-
      .event_message = .message
      .metadata.level = .severity
      .metadata.timestamp = .timestamp
      .metadata.app = .appname
      .metadata.ip = .source_ip
      .metadata.project = "default"
      del(.message)
      del(.procid)
      del(.severity)
      del(.source_id)
      del(.source_type)
      del(.timestamp)
      del(.facility)
      del(.host)
      del(.id)
      del(.appname)
  rest_logs:
    type: remap
    inputs:
      - router.rest
    source: |-
      .event_message = .message
      .metadata.level = .severity
      .metadata.timestamp = .timestamp
      .metadata.app = .appname
      .metadata.ip = .source_ip
      .metadata.project = "default"
      del(.message)
      del(.procid)
      del(.severity)
      del(.source_id)
      del(.source_type)
      del(.timestamp)
      del(.facility)
      del(.host)
      del(.id)
      del(.appname)
  realtime_logs:
    type: remap
    inputs:
      - router.realtime
    source: |-
      .event_message = .message
      .metadata.level = .severity
      .metadata.timestamp = .timestamp
      .metadata.app = .appname
      .metadata.ip = .source_ip
      .metadata.project = "default"
      del(.message)
      del(.procid)
      del(.severity)
      del(.source_id)
      del(.source_type)
      del(.timestamp)
      del(.facility)
      del(.host)
      del(.id)
      del(.appname)
  storage_logs:
    type: remap
    inputs:
      - router.storage
    source: |-
      .event_message = .message
      .metadata.level = .severity
      .metadata.timestamp = .timestamp
      .metadata.app = .appname
      .metadata.ip = .source_ip
      .metadata.project = "default"
      del(.message)
      del(.procid)
      del(.severity)
      del(.source_id)
      del(.source_type)
      del(.timestamp)
      del(.facility)
      del(.host)
      del(.id)
      del(.appname)
  db_logs:
    type: remap
    inputs:
      - router.db
    source: |-
      .event_message = .message
      .metadata.level = .severity
      .metadata.timestamp = .timestamp
      .metadata.app = .appname
      .metadata.ip = .source_ip
      .metadata.project = "default"
      del(.message)
      del(.procid)
      del(.severity)
      del(.source_id)
      del(.source_type)
      del(.timestamp)
      del(.facility)
      del(.host)
      del(.id)
      del(.appname)

sinks:
  logflare_auth:
    type: 'http'
    inputs:
      - auth_logs
    encoding:
      codec: 'json'
    method: 'post'
    request:
      retry_max_duration_secs: 10
    uri: 'http://{{ .LogflareId }}:4000/api/logs?source_name=gotrue.logs.prod&api_key={{ .ApiKey }}'
  logflare_realtime:
    type: 'http'
    inputs:
      - realtime_logs
    encoding:
      codec: 'json'
    method: 'post'
    request:
      retry_max_duration_secs: 10
    uri: 'http://{{ .LogflareId }}:4000/api/logs?source_name=realtime.logs.prod&api_key={{ .ApiKey }}'
  logflare_rest:
    type: 'http'
    inputs:
      - rest_logs
    encoding:
      codec: 'json'
    method: 'post'
    request:
      retry_max_duration_secs: 10
    uri: 'http://{{ .LogflareId }}:4000/api/logs?source_name=postgREST.logs.prod&api_key={{ .ApiKey }}'
  logflare_db:
    type: 'http'
    inputs:
      - db_logs
    encoding:
      codec: 'json'
    method: 'post'
    request:
      retry_max_duration_secs: 10
    # We must route the sink through kong because ingesting logs before logflare is fully initialised will
    # lead to broken queries from studio. This works by the assumption that containers are started in the
    # following order: vector > db > logflare > kong
    uri: 'http://{{ .KongId }}:8000/analytics/v1/api/logs?source_name=postgres.logs&api_key={{ .ApiKey }}'
  logflare_storage:
    type: 'http'
    inputs:
      - storage_logs
    encoding:
      codec: 'json'
    method: 'post'
    request:
      retry_max_duration_secs: 10
    uri: 'http://{{ .LogflareId }}:4000/api/logs?source_name=storage.logs.prod.2&api_key={{ .ApiKey }}'
  logflare_kong:
    type: 'http'
    inputs:
      - kong_logs
    encoding:
      codec: 'json'
    method: 'post'
    request:
      retry_max_duration_secs: 10
    uri: 'http://{{ .LogflareId }}:4000/api/logs?source_name=cloudflare.logs.prod&api_key={{ .ApiKey }}'
